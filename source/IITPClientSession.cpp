//
// FTPClientSession.cpp
//
// $Id: //poco/1.4/Net/src/FTPClientSession.cpp#1 $
//
// Library: Net
// Package: FTP
// Module:  FTPClientSession
//
// Copyright (c) 2005-2006, Applied Informatics Software Engineering GmbH.
// and Contributors.
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.
//


#include "IITPClientSession.h"
#include "Poco/Net/SocketAddress.h"
#include "Poco/Net/SocketStream.h"
#include "Poco/Net/ServerSocket.h"
#include "Poco/Net/NetException.h"
#include "Poco/NumberFormatter.h"
#include "Poco/Ascii.h"
#include <algorithm>

namespace Innovative {


IITPClientSession::IITPClientSession(const StreamSocket& socket):
	_controlSocket(socket),
	_pDataStream(0),
	_isOpen(true),
	_timeout(DEFAULT_TIMEOUT)
{
	_controlSocket.setReceiveTimeout(_timeout);
}

	
IITPClientSession::IITPClientSession(const std::string& host, Poco::UInt16 port):
	_controlSocket(SocketAddress(host, port)),
	_pDataStream(0),
	_isOpen(true),
	_timeout(DEFAULT_TIMEOUT)
{
	_controlSocket.setReceiveTimeout(_timeout);
}


IITPClientSession::~IITPClientSession()
{
	try
	{
		close();
	}
	catch (...)
	{
	}
}


void IITPClientSession::setTimeout(const Poco::Timespan& timeout)
{
	_timeout = timeout;
	_controlSocket.setReceiveTimeout(timeout);
}

	
Poco::Timespan IITPClientSession::getTimeout() const
{
	return _timeout;
}

void IITPClientSession::login(const std::string& username, const std::string& password)
{
	std::string response;
	int status = _controlSocket.receiveStatusMessage(response);
    if (!isPositiveCompletion(status)) throw Poco::Net::FTPException("Cannot login to server", response, status);
	status = sendCommand("USER", username, response);
    if (isPositiveCompletion(status))
		status = sendCommand("PASS", password, response);
    if (!isPositiveCompletion(status)) throw  Poco::Net::FTPException("Login denied", response, status);
}


void IITPClientSession::close()
{
	if (_isOpen)
	{
		try
		{
			endTransfer(); 
		}
		catch (...)
		{
		}
		std::string response;
		sendCommand("QUIT", response);
		_controlSocket.close();
		_isOpen = false;
	}
}

void IITPClientSession::setWorkingDirectory(const std::string& path)
{
	std::string response;
    int status = sendCommand("CWD", "dir", path, response);
    if (!isPositiveCompletion(status)) throw Poco::Net::FTPException("Cannot change directory", response, status);
}


std::string IITPClientSession::getWorkingDirectory()
{
	std::string response;
	int status = sendCommand("PWD", response);
	if (isPositiveCompletion(status))
		return extractPath(response);
	else
        throw Poco::Net::FTPException("Cannot get current working directory", response, status);
}


void IITPClientSession::cdup()
{
	std::string response;
	int status = sendCommand("CDUP", response);
    if (!isPositiveCompletion(status)) throw Poco::Net::FTPException("Cannot change directory", response, status);
}

void IITPClientSession::setFile(const string &name)
{
    std::string response;
    int status = sendCommand("SNAME", "name", name, response);
    if (!isPositiveCompletion(status)) throw Poco::Net::FTPException("Cannot change directory", response, status);

}

	
void IITPClientSession::rename(const std::string& oldName, const std::string& newName)
{
	std::string response;
    vector<pair<std::string, std::string> > args;
    args.push_back(make_pair("from", oldName));
    args.push_back(make_pair("to", oldName));
    int status = sendCommand("RNTO", args, response);
    if (!isPositiveCompletion(status)) throw Poco::Net::FTPException(std::string("Cannot rename to ") + newName, response, status);
}

	
void IITPClientSession::remove(const std::string& path)
{
	std::string response;
    int status = sendCommand("DELE", "path", path, response);
    if (!isPositiveCompletion(status)) throw Poco::Net::FTPException(std::string("Cannot remove " + path), response, status);
}


void IITPClientSession::mkdir(const std::string& path)
{
	std::string response;
    int status = sendCommand("MKD", "path", path, response);
    if (!isPositiveCompletion(status)) throw Poco::Net::FTPException(std::string("Cannot create directory ") + path, response, status);
}


void IITPClientSession::rmdir(const std::string& path)
{
	std::string response;
    int status = sendCommand("RMD", "path", path, response);
    if (!isPositiveCompletion(status)) throw Poco::Net::FTPException(std::string("Cannot remove directory ") + path, response, status);
}


std::istream& IITPClientSession::beginPlay()
{
	delete _pDataStream;
	_pDataStream = 0;
    _pDataStream = new SocketStream(establishDataConnection("PLAY"));
	return *_pDataStream;
}

	
void IITPClientSession::endPlay()
{
	endTransfer();
}

	
std::ostream &IITPClientSession::beginStore()
{
	delete _pDataStream;
	_pDataStream = 0;
    _pDataStream = new SocketStream(establishDataConnection("STOR"));
	return *_pDataStream;
}


void IITPClientSession::endStore()
{
	endTransfer();
}

int IITPClientSession::sendCommand(const std::string& command, std::string& response)
{
	_controlSocket.sendMessage(command);
	return _controlSocket.receiveStatusMessage(response);
}

int IITPClientSession::sendCommand(const std::string& command, const std::string& arg, std::string& response)
{
	_controlSocket.sendMessage(command, arg);
	return _controlSocket.receiveStatusMessage(response);
}

int IITPClientSession::sendCommand(const std::string& command, const std::string& arg1, const std::string& arg2, std::string& response)
{
    _controlSocket.sendMessage(command, arg1, arg2);
    return _controlSocket.receiveStatusMessage(response);
}


int IITPClientSession::sendCommand(const std::string& command, const vector<pair<std::string, std::string> > &args, std::string& response)
{
    _controlSocket.sendMessage(command);

    string line(command);
    line.append(" ");
    for (size_t i = 0; i < args.size(); i++)
        line += paramPack(args[i]);
    line.append("\r\n");
    _controlSocket.sendString(line);

    return _controlSocket.receiveStatusMessage(response);
}

std::string IITPClientSession::paramPack(const pair<std::string, std::string> &arg)
{
    std::string line;
    line.reserve(arg.first.length() + arg.second.length() + 2);
    line.append(arg.first);
    if (!arg.second.empty())
    {
        line.append(" ");
        line.append(arg.second);
    }
    line.append(" ");

    return line;
}

void IITPClientSession::sendBuffer(const Innovative::Buffer &b)
{
    if (_pDataStream) {
        _pDataStream->write(reinterpret_cast<const char*>(b.ConstHeader()), b.HeaderSizeInBytes());
        _pDataStream->write(reinterpret_cast<const char*>(b.ConstData()), b.SizeInBytes());
    }
}

std::string IITPClientSession::extractPath(const std::string& response)
{
	std::string path;
	std::string::const_iterator it  = response.begin();
	std::string::const_iterator end = response.end();
	while (it != end && *it != '"') ++it;
	if (it != end)
	{
		++it;
		while (it != end)
		{
			if (*it == '"')
			{
				++it;
				if (it == end || (it != end && *it != '"')) break;
			}
			path += *it++;
		}
	}
	return path;
}


StreamSocket IITPClientSession::establishDataConnection(const std::string& command)
{
   return passiveDataConnection(command);
}


StreamSocket IITPClientSession::passiveDataConnection(const std::string& command)
{
    SocketAddress sa("127.0.0.1", "9981");
	StreamSocket sock(sa);
	std::string response;
    int status = sendCommand(command, response);
    if (!isPositiveCompletion(status)) throw Poco::Net::FTPException(command + " command failed", response, status);
	return sock;
}


void IITPClientSession::sendPortCommand(const SocketAddress& addr)
{
	sendPORT(addr);
}

void IITPClientSession::sendPORT(const SocketAddress& addr)
{
	std::string arg(addr.host().toString());
	for (std::string::iterator it = arg.begin(); it != arg.end(); ++it)
	{
		if (*it == '.') *it = ',';
	}
	arg += ',';
	Poco::UInt16 port = addr.port();
    arg += Poco::NumberFormatter::format(port/256);
	arg += ',';
    arg += Poco::NumberFormatter::format(port % 256);
	std::string response;
    int status = sendCommand("PORT", "port", arg, response);
    if (!isPositiveCompletion(status)) throw Poco::Net::FTPException("PORT command failed", response, status);
}

void IITPClientSession::endTransfer()
{
	if (_pDataStream)
	{
		delete _pDataStream;
		_pDataStream = 0;
        std::string response;
        int status = sendCommand("ETOR", response);
        if (!isPositiveCompletion(status)) throw Poco::Net::FTPException("Data transfer failed", response, status);
	}
}


}
